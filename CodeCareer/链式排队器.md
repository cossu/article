中断判优逻辑：链式排队器
计算机组成原理（唐朔飞）版「程序中断」一节中关于链式排队器的说明过于简洁，初读之下实在难以领会精妙所在，上网搜索也没有预见让我满意的答案。于是就有了这篇日志。

链式排队器是处理「设备中断优先权」的一种硬件实现方法。现将各个接口电路中的排队电路抽取如下：

0![](D:\article\article\CodeCareer\0.png)
图注：
1：这个器件是「反向器」，它能够将输入数据「取反」后输出
2：这个器件是「与非门」，他能够将输入数据先做「与」操作，再做「非」操作，然后输出。
3：这个标识符意味将原数输入。
4：这个标识符意味将原数「取反」后输入。下文用「INTR非」+相应序号对其进行代称。
想要搞明白排队器究竟是怎么工作的只要读懂上图即可。
图中电路流通从左开始，最左边一根是接地线，始终向INTP1‘中的反向器输入0。
中断源申请中断，则INTR为1，INTR非为0。
现假设无中断源申请中断，则所有INTR非输入为1，INTR输入为0。
则INTP1‘向上所对应的与非门输入数据分别为「1」和「0」.根据与非门的计算逻辑得输出为1，再经过一道反向器，则最终INTP1的输出为0。
同时INTP1‘向右所对应的与非门输入数据为「1」和「1」，易知输出、传递给INTP2‘的数据为「0」，此时，INTR2非和INTR2的输入数据已知为「1」和「0」，则重复上述流程易得输出结果为「0」。
INTP3‘与INTP4’同理。
可以看出，在都没有发出中断请求的时候，INTP‘从左到右传递的数据保持了一致，都是「0」。
所以输出的最后结果是「0000」。
那么排队器是如何做到排队的呢？或者说，排队器是如何做到挑出优先等级最高的那个中断请求，然后屏蔽其他优先等级低的请求呢？看下面的一个例子。
假如，现在有1号和2号中断源向cpu发起了中断请求，则输入「INTR非」为「0011」。
先看INTP1‘。INTP1’向上所对应的与非门所对应输入数据为「1」和「1」，输出为「0」，经由一个反向器最终输出为「1」.
而INTP1‘向右的与非门输入数据为「1」，「0」。则传递给INTP2’的数据为「1」。
再看INTP2’，INTP2‘向上所对应的与非门输入数据为「0」（从INTP1’所过来的数据经过了一道反向器所以从「1」变成了「0」）和「1」。故已知，最终INTP2输出为0。
可以看出，在有中断源发出中断请求的时候，INTP’从左接收到的数据，从最左边一个接受到中断请求的中断电路开始，从左到右传递的数据就都变成了「1」。
这里容易看到，排队器的实质在于INTP向右的这一条「反向器」+「与非门」组合电路。只要右边有了中断请求，即INTR非为「0」，则通过组合电路后其输出值必为「0」。根据「与非门」的逻辑计算特点，只要输入数据中有一个为「0」，则输出结果就是「1」，再经过一个反向器，则INTP输出必为「0」。进而打到了优先等级从左到右依次降低的排队效果。
注：「与非门」的「与非」逻辑计算真值表。
           输入 输出
           1  1      0
           1  0      1
           0  1      1
           0  0      1